# Section Extract Service

## Purpose

Retrieve a single section from a stored sales-quote template as a fully formatted `.docx` file, preserving the original document's headers, footers, page layout, styles, fonts, tables, and images.

## Endpoint

```
GET /api/v1/templates/{plsqt_id}/sections/{seqn}/docx
```

## Parameters

| Parameter  | Type | Required | Description |
|------------|------|----------|-------------|
| `plsqt_id` | int  | Yes      | Template ID from `plsq_templates` |
| `seqn`     | int  | Yes      | Section sequence number (0 = cover page, 1–12 = numbered sections) |

## What It Does

1. Looks up the template record by `plsqt_id`
2. Reads `current_blob_id` to locate the stored `.docx` file
3. Looks up the `plsqt_sections` record for the requested `seqn`, joined to `plsqts_type`
4. Resolves the section name:
   - Uses `plsqts_alt_name` if `plsqts_use_alt_name` is true
   - Otherwise uses `plsqtst_name` from the section type record
5. Fetches the `.docx` bytes from `document_blob`
6. Clones the full document in memory
7. Parses section boundaries using the same heading-detection logic as the batch loader
8. Removes all body elements that don't belong to the requested section
9. Returns the result as a downloadable `.docx` file

## Successful Response (HTTP 200)

The response body is the `.docx` file bytes.

### Headers

| Header | Value |
|--------|-------|
| `Content-Type` | `application/vnd.openxmlformats-officedocument.wordprocessingml.document` |
| `Content-Disposition` | `attachment; filename="plsqts_content_{plsqt_id}_{blob_id}_{seqn}_{section_name}.docx"` |
| `X-Section-Count` | Total number of sections stored for this template |
| `X-Content-Length` | Size in bytes of the returned `.docx` |

### Filename Example

```
plsqts_content_41_14_4_Product_Pump.docx
```

Spaces in the section name are replaced with underscores.

## Error Responses

| HTTP Code | Condition | Example Detail |
|-----------|-----------|----------------|
| 404 | Template not found | `"Template not found: 9999"` |
| 404 | Template has no stored document (`current_blob_id` is NULL) | `"No document stored for template 41"` |
| 404 | No section record with this sequence number | `"No section 99 for template 41"` |
| 404 | Section not found in the parsed document | `"Section 99 not found in parsed document for template 41"` |
| 404 | Blob row missing from `document_blob` | `"Blob 14 not found in document_blob"` |
| 422 | Invalid parameter type (e.g. non-integer) | Auto-generated by FastAPI |
| 500 | Unexpected server error | — |

## What Is Preserved in the Extracted Document

The extraction uses a clone-and-strip approach: the full `.docx` is cloned, then all body content outside the requested section is removed. This preserves:

- Tables with full formatting (borders, shading, merged cells, column widths)
- Paragraph formatting (fonts, bold, italic, sizes, colors, spacing)
- Inline images
- Bullet and numbered lists
- Document headers and footers
- Page layout (margins, orientation, page size)
- Style definitions, fonts, and theme

## Section Name Resolution

Each section record in `plsqt_sections` has a `section_type_id` pointing to `plsqts_type`, which provides the standard name (e.g. "Product Pump"). However, if `plsqts_use_alt_name` is true on the section record, the `plsqts_alt_name` field is used instead. This allows individual sections to override the standard type name.

## Testing with curl

```bash
# Extract section 4 from template 41
curl -o section4.docx 'http://127.0.0.1:8000/api/v1/templates/41/sections/4/docx'

# Extract cover page
curl -o cover.docx 'http://127.0.0.1:8000/api/v1/templates/41/sections/0/docx'

# Show headers only (no file download)
curl -s -D - -o /dev/null 'http://127.0.0.1:8000/api/v1/templates/41/sections/4/docx'

# Test error case
curl -s 'http://127.0.0.1:8000/api/v1/templates/41/sections/99/docx'
```

## Calling from Node.js / JavaScript

This is a simple `GET` with path parameters — no request body, no multipart form, no authentication.

### Download the .docx as a Buffer (Node.js backend)

```js
const res = await fetch(
  `http://127.0.0.1:8000/api/v1/templates/${plsqtId}/sections/${seqn}/docx`
);

if (!res.ok) {
  const err = await res.json();
  throw new Error(err.detail);     // e.g. "No section 99 for template 41"
}

const sectionCount = res.headers.get("X-Section-Count");
const filename = res.headers
  .get("Content-Disposition")
  .match(/filename="(.+)"/)?.[1];

const docxBuffer = Buffer.from(await res.arrayBuffer());
// docxBuffer is now the .docx file — save to disk, forward to client, etc.
```

### Trigger a browser download (front-end)

```js
const url =
  `http://127.0.0.1:8000/api/v1/templates/${plsqtId}/sections/${seqn}/docx`;

// Option A: direct link (simplest)
window.open(url);

// Option B: fetch + programmatic download (if you need to handle errors first)
const res = await fetch(url);
if (!res.ok) {
  const err = await res.json();
  alert(err.detail);
  return;
}
const blob = await res.blob();
const a = document.createElement("a");
a.href = URL.createObjectURL(blob);
a.download = res.headers
  .get("Content-Disposition")
  .match(/filename="(.+)"/)?.[1] ?? "section.docx";
a.click();
URL.revokeObjectURL(a.href);
```

### Render in a docx viewer component

If using a library like `docx-preview` or similar to render `.docx` content in the browser:

```js
const res = await fetch(
  `http://127.0.0.1:8000/api/v1/templates/${plsqtId}/sections/${seqn}/docx`
);
const arrayBuffer = await res.arrayBuffer();
// Pass arrayBuffer to your docx rendering library
```

### CORS

The API allows cross-origin requests from origins listed in the `LISTLDR_CORS_ORIGINS` environment variable (default: `http://localhost:3000`). The `GET` method is allowed alongside `POST`. See the [API Testing Guide](api_testing_guide.md) for CORS configuration details.

## Note on Section Boundaries

Section boundaries are determined by the parser's heading-detection logic, not by Word's internal section breaks. In cases where a section heading appears in the last row of the previous section's table (a "trailing heading"), the table stays with the previous section and the new section starts after it. This matches the behavior of the batch loader.
